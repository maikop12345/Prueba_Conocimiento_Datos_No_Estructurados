# -*- coding: utf-8 -*-
"""Proyecto Clasificación.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J7cbU50cL93kgZa1kaXkWNkn1eQPrI-e
"""

!pip install pytesseract opencv-python pillow numpy
!apt-get install tesseract-ocr

import cv2
import pytesseract
from google.colab import files
import nltk
from nltk.corpus import words

# Descargar el corpus de palabras en inglés
nltk.download('words')

uploaded = files.upload()

def contains_min_english_words_of_length(text, min_count=4, min_length=6):
    english_words = set(words.words())
    text_words = text.lower().split()

    # Contar cuántas palabras en el texto están en el diccionario inglés y tienen al menos min_length caracteres
    long_english_word_count = sum(1 for word in text_words if word in english_words and len(word) >= min_length)

    return long_english_word_count >= min_count

def has_content(image_path):
    # Cargar y convertir la imagen a escala de grises
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Aplicar un filtro para reducir el ruido
    gray = cv2.GaussianBlur(gray, (5, 5), 0)

    # Umbralización para binarizar la imagen
    gray = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]

    # Usar OCR para extraer el texto
    text = pytesseract.image_to_string(gray)

    # Verificar si la palabra "FOR" o "for" está en el texto
    if "for" in text.lower():
        return True

    # Evaluar si la imagen tiene contenido basado en la longitud del texto
    text_length_criteria = len(text.strip()) > 30  # Ajustar este umbral según la sensibilidad

    # Detectar bordes en la imagen
    edges = cv2.Canny(gray, 100, 200)
    has_significant_edges = cv2.countNonZero(edges) > 5000  # Aumentar este umbral para reducir falsos positivos

    # Comprobar si el texto contiene al menos 4 palabras en inglés de 6 caracteres o más
    contains_required_words = contains_min_english_words_of_length(text, min_count=8, min_length=6)

    # Evaluar si la imagen tiene contenido
    return text_length_criteria and has_significant_edges and contains_required_words

# Clasificación de las imágenes
with_content = []
without_content = []

for filename in uploaded.keys():
    if has_content(filename):
        with_content.append(filename)
    else:
        without_content.append(filename)

print("Imágenes con contenido:", with_content)
print("Imágenes sin contenido:", without_content)